package com.example.ev3;

import java.util.HashMap;

import com.j4ev3.core.*;
import com.streambase.sb.*;
import com.streambase.sb.operator.*;
import com.streambase.sb.util.Util;

/**
 * Generated by JDT StreamBase Client Templates (Version: 10.6.1.2008190131).
 *
 * This class is used as a Java Operator in a StreamBase application.
 * One instance will be created for each Java Operator in a StreamBase 
 * application. 
 * <p>
 * Enqueue methods should only be called from processTuple.
 * @see Parameterizable
 * @see Operator
 * For in-depth information on implementing a custom Java Operator, please see
 * "Developing StreamBase Java Operators" in the StreamBase documentation.
 */
public class EV3StatusAdapter extends Operator implements Parameterizable,ISharableAdapter,Runnable {

	public static final long serialVersionUID = 1623698966801L;
	// Properties
	private OutputTypeEnum OutputType;

	// Enum definition for property OutputType
	public static enum OutputTypeEnum {
		RAW("Raw"), SI("SI"), PERCENT("Percent");

		private final String rep;

		private OutputTypeEnum(String s) {
			rep = s;
		}

		public String toString() {
			return rep;
		}
	}
	
	private boolean StreamPortA;
	private boolean StreamPortB;
	private boolean StreamPortC;
	private boolean StreamPortD;
	private boolean StreamPort1;
	private boolean StreamPort2;
	private boolean StreamPort3;
	private boolean StreamPort4;
	
	private SensorTypeEnum Port1Device;
	private SensorTypeEnum Port2Device;
	private SensorTypeEnum Port3Device;
	private SensorTypeEnum Port4Device;
	
	private boolean PortAMotor;
	private boolean PortBMotor;
	private boolean PortCMotor;
	private boolean PortDMotor;
	
	
	private EV3SharedObject connectTo;
	public String ConnectionManagerName;
	
	
	private String displayName = "MINDSTORMS EV3 Input Adapter";
	// Local variables
	private int inputPorts = 1;
	private int outputPorts = 8;
	private int nextOutputPort = 0;
	private Schema[] outputSchemas; // caches the Schemas given during init() for use at processTuple()
	private HashMap<String, Integer> outputPortNames;
	
	//Input schema definition
	private static Schema.Field FIELD_TARGET_PORT = Schema.createField(DataType.STRING, "TargetPort");
	private static Schema.Field FIELD_STREAM = Schema.createField(DataType.BOOL, "Stream");
	private static Schema.Field FIELD_SENSOR_MODE  = Schema.createField(DataType.INT, "SensorMode");
	
	//Output schema fieldnames
	private static String FIELD_DEGREES = "Degrees";
	private static String FIELD_ROTATION = "Rotation";
	private static String FIELD_POWER = "Power";

	private static String FIELD_LEFT = "LeftButton";
	private static String FIELD_CENTER = "CenterButton";
	private static String FIELD_RIGHT = "RightButton";
	private static String FIELD_UP = "UpButton";
	private static String FIELD_DOWN = "DownButton";
	
	private static String FIELD_LISTEN = "Listen";
	private static String FIELD_TOUCH = "Touch";
	private static String FIELD_BUMPED = "Bumped";
	private static String FIELD_COLOR = "Color";
	private static String FIELD_REFLECT = "LightReflected";
	private static String FIELD_AMBIENT = "LightAmbient";
	private static String FIELD_DIST_CM = "Distance(cm)";
	private static String FIELD_DIST_IN = "Distance(in)";
	private static String FIELD_ANGLE = "Angle";
	private static String FIELD_RATE = "Rate";
	private static String FIELD_PROXIMITY = "Proximity";

	/**
	* The constructor is called when the Operator instance is created, but before the Operator 
	* is connected to the StreamBase application. We recommended that you set the initial input
	* port and output port count in the constructor by calling setPortHints(inPortCount, outPortCount).
	* The default is 1 input port, 1 output port. The constructor may also set default values for 
	* operator parameters. These values will be displayed in StreamBase Studio when a new instance
	* of this operator is  dragged to the canvas, and serve as the default values for omitted
	* optional parameters.
	 */
	public EV3StatusAdapter() {
		super();
		setPortHints(inputPorts, outputPorts);
		setDisplayName(displayName);
		setShortDisplayName(this.getClass().getSimpleName());
		setConnectionManagerName("");
		setStreamPortA(false);
		setStreamPortB(false);
		setStreamPortC(false);
		setStreamPortD(false);
		setStreamPort1(false);
		setStreamPort2(false);
		setStreamPort3(false);
		setStreamPort4(false);
		
		setPort1Device(SensorTypeEnum.NONE);
		setPort2Device(SensorTypeEnum.NONE);
		setPort3Device(SensorTypeEnum.NONE);
		setPort4Device(SensorTypeEnum.NONE);
		
		setPortAMotor(false);
		setPortBMotor(false);
		setPortCMotor(false);
		setPortDMotor(false);
	}

	/**
	* The typecheck method is called after the Operator instance is connected in the StreamBase
	* application, allowing the Operator to validate its properties. The Operator class may 
	* change the number of input or output ports by calling the requireInputPortCount(portCount)
	* method or the setOutputSchema(schema, portNum) method. If the verifyInputPortCount method 
	* is passed a different number of ports than the Operator currently has, a PortMismatchException
	* (subtype of TypecheckException) is thrown.
	*/
	public void typecheck() throws TypecheckException {
		// typecheck: require a specific number of input ports
		requireInputPortCount(inputPorts);

		// TODO Ensure that all properties have valid values, and typecheck the input schemas here
		
		if(ConnectionManagerName.length() < 1) {
			throw new TypecheckException(String.format("The 'Linked Connection Manager Name' must not be left blank."));
		}
		if (getInputSchema(0) == null || !getInputSchema(0).hasField(FIELD_TARGET_PORT.getName())) {
            throw new TypecheckException(String.format("The control port schema must at least have a field named %s of type String", FIELD_TARGET_PORT.getName()));
        }
		

		// you must specify a setOutputSchema for each port, so that StreamBase Studio
		// knows how many output ports to draw for the output ports. If you do not
		// use setOutputSchema for each port, the Java Operator on the StreamBase Studio
		// canvas will not display the correct number of output ports.
		
		
		int portNumber = 0;
		
		//button port
		setOutputSchema(portNumber, createButtonOutputSchema(""));
		
		//one for each motor connected
		if (isPortAMotor()) {
			portNumber++;
			setOutputSchema(portNumber, createMotorOutputSchema(""));
			//getLogger().debug("Port A: true");
		}
		if (isPortBMotor()) {
			portNumber++;
			setOutputSchema(portNumber, createMotorOutputSchema(""));
			//getLogger().debug("Port B: true");
		}
		if (isPortCMotor()) {
			portNumber++;
			setOutputSchema(portNumber, createMotorOutputSchema(""));
			//getLogger().debug("Port C: true");
		}
		if (isPortDMotor()) {
			portNumber++;
			setOutputSchema(portNumber, createMotorOutputSchema(""));
			//getLogger().debug("Port D: true");
		}
		
		//one for each applicable sensor
		if (getPort1Device() != SensorTypeEnum.NONE) {
			portNumber++;
			setOutputSchema(portNumber, getSchemaForSensorType(getPort1Device()));
			//getLogger().debug("Port 1: " + getPort1Device());
		}
		if (getPort2Device() != SensorTypeEnum.NONE) {
			portNumber++;
			setOutputSchema(portNumber, getSchemaForSensorType(getPort2Device()));
			//getLogger().debug("Port 2: " + getPort2Device());
		}
		if (getPort3Device() != SensorTypeEnum.NONE) {
			portNumber++;
			setOutputSchema(portNumber, getSchemaForSensorType(getPort3Device()));
			//getLogger().debug("Port 3: " + getPort3Device());
		}
		if (getPort4Device() != SensorTypeEnum.NONE) {
			portNumber++;
			setOutputSchema(portNumber, getSchemaForSensorType(getPort4Device()));
			//getLogger().debug("Port 4: " + getPort4Device());
		}
		
		outputPorts = portNumber+1;//since the ports start at index zero the number will be one more

	}

	/**
	* This method will be called by the StreamBase server for each Tuple given
	* to the Operator to process. This is the only time an operator should 
	* enqueue output Tuples.
	* @param inputPort the input port that the tuple is from (ports are zero based)
	* @param tuple the tuple from the given input port
	* @throws StreamBaseException Terminates the application.
	*/
	public void processTuple(int inputPort, Tuple tuple) throws StreamBaseException {
		if (getLogger().isInfoEnabled()) {
			getLogger().info("operator processing a tuple at input port" + inputPort);
		}
		// TODO only the first input port is processed
		if (inputPort == 0) {
			String target = tuple.getString(FIELD_TARGET_PORT.getName());
			if (outputPortNames.containsKey(target)) {
				int outputPort = outputPortNames.get(target);
				Tuple out = buildSensorTuple(target);
				sendOutput(outputPort, out);
				//TODO change any values required
			}else {
				getLogger().warn(String.format("No output port available for target %s", target));
			}
		}
		//TODO process button values
	}
	
	public Tuple buildSensorTuple(String targetPort){
		int outputPort = outputPortNames.get(targetPort);
		byte outputPortByte = connectTo.getPortByte(targetPort);
		int sensorType;
		Tuple out = outputSchemas[outputPort].createTuple();
		
		try {
		
			switch (outputSchemas[outputPort].getName()) {
			case "motorSchema":
				sensorType = Sensor.TYPE_LARGE_MOTOR;
				//TODO check that this doesn't cause problems to call both motors "large"
				out = setFieldByOutputType(out, FIELD_DEGREES, outputPortByte, sensorType, Sensor.LARGE_MOTOR_DEGREE);
				out = setFieldByOutputType(out, FIELD_ROTATION, outputPortByte, sensorType, Sensor.LARGE_MOTOR_ROTATION);
				out = setFieldByOutputType(out, FIELD_POWER, outputPortByte, sensorType, Sensor.LARGE_MOTOR_POWER);
				break;
			case "touchSchema":
				sensorType = Sensor.TYPE_TOUCH;
				out = setFieldByOutputType(out, FIELD_TOUCH, outputPortByte, sensorType, Sensor.TOUCH_TOUCH);
				//TODO this one needs to be set as a boolean regardless
				//TODO actually what ARE these two values, and how do they differ? 
				out = setFieldByOutputType(out, FIELD_BUMPED, outputPortByte, sensorType, Sensor.TOUCH_BUMPS);
				//boolean isBumped = (connectTo.robot.getSensor().getValueRaw(outputPortByte, sensorType, Sensor.TOUCH_BUMPS) > 0.5);
				//out.setField(FIELD_BUMPED, isBumped);
				break;
			case "colorSchema":
				sensorType = Sensor.TYPE_COLOR;
				//out = setFieldByOutputType(out, FIELD_COLOR, outputPortByte, sensorType, Sensor.COLOR_COLOR);
				int color = connectTo.robot.getSensor().getValueRaw(outputPortByte, sensorType, Sensor.COLOR_COLOR);
				String colorName = ColorEnum.values()[color].toString();
				out.setField(FIELD_COLOR, colorName);
				out = setFieldByOutputType(out, FIELD_REFLECT, outputPortByte, sensorType, Sensor.COLOR_REFLECTED);
				out = setFieldByOutputType(out, FIELD_AMBIENT, outputPortByte, sensorType, Sensor.COLOR_AMBIENT);
				break;
			case "ultraSchema":
				sensorType = Sensor.TYPE_ULTRASONIC;
				out = setFieldByOutputType(out, FIELD_DIST_CM, outputPortByte, sensorType, Sensor.ULTRASONIC_CM );
				out = setFieldByOutputType(out, FIELD_DIST_IN, outputPortByte, sensorType, Sensor.ULTRASONIC_INCH);
				//out = setFieldByOutputType(out, FIELD_LISTEN, outputPortByte, sensorType, Sensor.ULTRASONIC_LISTEN);
				boolean listen = (connectTo.robot.getSensor().getValueRaw(outputPortByte, sensorType, Sensor.ULTRASONIC_LISTEN) > 0.5);
				out.setField(FIELD_LISTEN, listen);
				break;
			case "gyroSchema":
				sensorType = Sensor.TYPE_GYRO;
				out = setFieldByOutputType(out, FIELD_ANGLE, outputPortByte, sensorType, Sensor.GYRO_ANGLE );
				out = setFieldByOutputType(out, FIELD_RATE, outputPortByte, sensorType, Sensor.GYRO_RATE);
			case "irSchema":
				sensorType = Sensor.TYPE_IR;
				out = setFieldByOutputType(out, FIELD_PROXIMITY, outputPortByte, sensorType, Sensor.IR_PROXIMITY);
			default:
					break;
			}
		}catch (Exception e) {
			 getLogger().error("Error", e);
		}
		
		return out;
	}
	
	
	/**
	 * Handles the setting of sensor field according to the output type as set in "properties"
	 * @param tuple
	 * @param field
	 * @param port
	 * @param sensorType
	 * @param sensorMode
	 * @return Tuple with the appropriate field set
	 * @throws TupleException
	 */
	public Tuple setFieldByOutputType(Tuple tuple, String field, byte port, int sensorType, int sensorMode) throws TupleException {
		Sensor sensorRead = connectTo.robot.getSensor();
		switch (OutputType) {
		case RAW:
			tuple.setField(field, sensorRead.getValueRaw(port, sensorType, sensorMode));
			break;
		case SI:
			tuple.setField(field, sensorRead.getValueSI(port, sensorType, sensorMode));
			break;
		case PERCENT:
			tuple.setField(field, sensorRead.getValuePercent(port, sensorType, sensorMode));
			break;
		}
		
		return tuple;
	}
	
	

	/**
	 * If typecheck succeeds, the init method is called before the StreamBase application
	 * is started. Note that your Operator class is not required to define the init method,
	 * unless (for example) you need to perform initialization of a resource such as a JDBC
	 * pool, if your operator is making JDBC calls. StreamBase Studio does not call this
	 * during authoring.
	 */
	public void init() throws StreamBaseException {
		super.init();
		
		//connect to shared object;
		connectTo = EV3SharedObject.getSharedObjectInstance(this);
		
		// for best performance, consider caching input or output Schema.Field objects for
		// use later in processTuple()
		outputSchemas = new Schema[outputPorts];

		for (int i = 0; i < outputPorts; ++i) {
			outputSchemas[i] = getRuntimeOutputSchema(i);
		}
		
		//map each port name to the port number it connects to TODO
		outputPortNames = new HashMap<String, Integer>();
		int portNumber = 0;
		
		//TODO button output port command?
		
		//for the four motors:
		if (isPortAMotor()) {
			portNumber++;
			outputPortNames.put("A", portNumber);
		}
		if (isPortBMotor()) {
			portNumber++;
			outputPortNames.put("B", portNumber);
		}
		if (isPortCMotor()) {
			portNumber++;
			outputPortNames.put("C", portNumber);
		}
		if (isPortDMotor()) {
			portNumber++;
			outputPortNames.put("D", portNumber);
		}
		
		//for the four sensors:
		if (getPort1Device() != SensorTypeEnum.NONE) {
			portNumber++;
			outputPortNames.put("1", portNumber);
		}
		if (getPort2Device() != SensorTypeEnum.NONE) {
			portNumber++;
			outputPortNames.put("2", portNumber);
		}
		if (getPort3Device() != SensorTypeEnum.NONE) {
			portNumber++;
			outputPortNames.put("3", portNumber);
		}
		if (getPort4Device() != SensorTypeEnum.NONE) {
			portNumber++;
			outputPortNames.put("4", portNumber);
		}
	}
	
	public void run() {
		while (shouldRun()) {
			try { //TODO make the on/off stream value change
				if (StreamPortA) {
					String target = "A";
					int outputPort = outputPortNames.get(target);
					Tuple out = buildSensorTuple(target);
					sendOutput(outputPort, out);
				}
				if (StreamPortB) {
					String target = "B";
					int outputPort = outputPortNames.get(target);
					Tuple out = buildSensorTuple(target);
					sendOutput(outputPort, out);
				}
				if (StreamPortC) {
					String target = "C";
					int outputPort = outputPortNames.get(target);
					Tuple out = buildSensorTuple(target);
					sendOutput(outputPort, out);
				}
				if (StreamPortD) {
					String target = "D";
					int outputPort = outputPortNames.get(target);
					Tuple out = buildSensorTuple(target);
					sendOutput(outputPort, out);
				}
				if (StreamPort1) {
					String target = "1";
					int outputPort = outputPortNames.get(target);
					Tuple out = buildSensorTuple(target);
					sendOutput(outputPort, out);
				}
				if (StreamPort2) {
					String target = "2";
					int outputPort = outputPortNames.get(target);
					Tuple out = buildSensorTuple(target);
					sendOutput(outputPort, out);
				}
				if (StreamPort3) {
					String target = "3";
					int outputPort = outputPortNames.get(target);
					Tuple out = buildSensorTuple(target);
					sendOutput(outputPort, out);
				}
				if (StreamPort4) {
					String target = "4";
					int outputPort = outputPortNames.get(target);
					Tuple out = buildSensorTuple(target);
					sendOutput(outputPort, out);
				}
			}catch (Exception e) {
				 getLogger().error("Error", e);
			} 
		}
		shutdown();
	}

	/**
	*  The shutdown method is called when the StreamBase server is in the process of shutting down.
	*/
	public void shutdown() {

	}
	
	/*
	 * Define types of schema:
	 * 
	 * Input:
	 * Control
	 * 
	 * Output:
	 * -ButtonOutput
	 * -MotorOutput
	 * -TouchOutput
	 * -ColorOutput
	 * -UltraOutput
	 * -GyroOutput
	 * -IROutput
	 */
	
	 /**
	 * @param mainName
	 * @return Schema
	 */	 
	public Schema createButtonOutputSchema(String mainName) {
		Schema buttonSchema = new Schema("buttonSchema",
				new Schema.Field(FIELD_LEFT,CompleteDataType.forString()),
				new Schema.Field(FIELD_CENTER,CompleteDataType.forString()),
				new Schema.Field(FIELD_RIGHT,CompleteDataType.forString()),
				new Schema.Field(FIELD_UP,CompleteDataType.forString()),
				new Schema.Field(FIELD_DOWN,CompleteDataType.forString())
				);
		return buttonSchema;
	}
	
	 /**
	 * @param mainName
	 * @return Schema
	 */	 
	 public Schema createMotorOutputSchema(String mainName) {
		 CompleteDataType returnType = OutputType == OutputTypeEnum.PERCENT? CompleteDataType.forInt() : CompleteDataType.forDouble();
		 //if a percentage is requested, it will be an integer; otherwise a double
	        Schema motorSchema = new Schema("motorSchema",
	                    new Schema.Field(FIELD_DEGREES,returnType),
	                    new Schema.Field(FIELD_ROTATION,returnType),
	                    new Schema.Field(FIELD_POWER,returnType)
	                    );
	        return motorSchema;
	 }
	 
	 /**
	 * @param type
	 * @return Schema
	 */	 
	 public Schema getSchemaForSensorType (SensorTypeEnum type) {
		 switch(type) {
		 case TOUCH:
			 return createTouchOutputSchema("");
		 case COLOR:
			 return createColorOutputSchema("");
		 case ULTRA:
			 return createUltraOutputSchema("");
		 case GYRO:
			 return createGyroOutputSchema("");
		 case IR:
			 return createIROutputSchema("");
			 default:
				 return createMotorOutputSchema("");
		 }
	 }
	 
	 /**
	 * @param mainName
	 * @return Schema
	 */	 
	 public Schema createTouchOutputSchema(String mainName) {
		 CompleteDataType returnType = OutputType == OutputTypeEnum.PERCENT? CompleteDataType.forInt() : CompleteDataType.forDouble();
		 //if a percentage is requested, it will be an integer; otherwise a double
	        Schema touchSchema = new Schema(SensorTypeEnum.TOUCH.toString(),
	                    new Schema.Field(FIELD_TOUCH,returnType),
	                    new Schema.Field(FIELD_BUMPED,CompleteDataType.forBoolean())
	                    );
	        return touchSchema;
	 }
	 
	 /**
	 * @param mainName
	 * @return Schema
	 */	 
	 public Schema createColorOutputSchema(String mainName) {
		 CompleteDataType returnType = OutputType == OutputTypeEnum.PERCENT? CompleteDataType.forInt() : CompleteDataType.forDouble();
		 //if a percentage is requested, it will be an integer; otherwise a double
	        Schema colorSchema = new Schema(SensorTypeEnum.COLOR.toString(),
	        		new Schema.Field(FIELD_COLOR,CompleteDataType.forString()),
	        		new Schema.Field(FIELD_REFLECT, returnType),
	        		new Schema.Field(FIELD_AMBIENT, returnType)
	                    );
	        return colorSchema;
	 }
	 

	public static enum ColorEnum {
			NONE("None"), BLACK("Black"),BLUE("Blue"),GREEN("Green"),YELLOW("Yellow"),RED("Red"),WHITE("White"),BROWN("Brown");

			private final String rep;

			private ColorEnum(String s) {
				rep = s;
			}

			public String toString() {
				return rep;
			}
		}
	 
	 /**
	 * @param mainName
	 * @return Schema
	 */
	public Schema createUltraOutputSchema(String mainName) {
		 CompleteDataType returnType = OutputType == OutputTypeEnum.PERCENT? CompleteDataType.forInt() : CompleteDataType.forDouble();
		 //if a percentage is requested, it will be an integer; otherwise a double
	        Schema ultraSchema = new Schema(SensorTypeEnum.ULTRA.toString(),
	                    new Schema.Field(FIELD_DIST_CM,returnType),
	                    new Schema.Field(FIELD_DIST_IN,returnType),
	                    new Schema.Field(FIELD_LISTEN,CompleteDataType.forBoolean())
	                    );
	        return ultraSchema;
	 }
	 
	 /**
	 * @param mainName
	 * @return Schema
	 */	 
	 public Schema createGyroOutputSchema(String mainName) {
		 CompleteDataType returnType = OutputType == OutputTypeEnum.PERCENT? CompleteDataType.forInt() : CompleteDataType.forDouble();
		 //if a percentage is requested, it will be an integer; otherwise a double
	        Schema gyroSchema = new Schema(SensorTypeEnum.GYRO.toString(),
	                    new Schema.Field(FIELD_ANGLE,returnType),
	                    new Schema.Field(FIELD_RATE,returnType)
	                    );
	        return gyroSchema;
	 }
	 
	 
	 /**
	 * @param mainName
	 * @return Schema
	 */	 
	 public Schema createIROutputSchema(String mainName) {
		 CompleteDataType returnType = OutputType == OutputTypeEnum.PERCENT? CompleteDataType.forInt() : CompleteDataType.forDouble();
		 //if a percentage is requested, it will be an integer; otherwise a double
	        Schema IRSchema = new Schema(SensorTypeEnum.IR.toString(),
	                    new Schema.Field(FIELD_PROXIMITY,returnType)
	                    );
	        return IRSchema;
	 }

	/***************************************************************************************
	 * The getter and setter methods provided by the Parameterizable object.               *
	 * StreamBase Studio uses them to determine the name and type of each property         *
	 * and obviously, to set and get the property values.                                  *
	 ***************************************************************************************/

	public void setOutputType(OutputTypeEnum OutputType) {
		this.OutputType = OutputType;
	}

	public OutputTypeEnum getOutputType() {
		return this.OutputType;
	}

	public void setStreamPortA(boolean StreamPortA) {
		this.StreamPortA = StreamPortA;
	}

	public boolean getStreamPortA() {
		return this.StreamPortA;
	}

	public void setStreamPortB(boolean StreamPortB) {
		this.StreamPortB = StreamPortB;
	}

	public boolean getStreamPortB() {
		return this.StreamPortB;
	}

	public void setStreamPortC(boolean StreamPortC) {
		this.StreamPortC = StreamPortC;
	}

	public boolean getStreamPortC() {
		return this.StreamPortC;
	}

	public void setStreamPortD(boolean StreamPortD) {
		this.StreamPortD = StreamPortD;
	}

	public boolean getStreamPortD() {
		return this.StreamPortD;
	}

	public void setStreamPort1(boolean StreamPort1) {
		this.StreamPort1 = StreamPort1;
	}

	public boolean getStreamPort1() {
		return this.StreamPort1;
	}

	public void setStreamPort2(boolean StreamPort2) {
		this.StreamPort2 = StreamPort2;
	}

	public boolean getStreamPort2() {
		return this.StreamPort2;
	}

	public void setStreamPort3(boolean StreamPort3) {
		this.StreamPort3 = StreamPort3;
	}

	public boolean getStreamPort3() {
		return this.StreamPort3;
	}

	public void setStreamPort4(boolean StreamPort4) {
		this.StreamPort4 = StreamPort4;
	}

	public boolean getStreamPort4() {
		return this.StreamPort4;
	}

	public int getNextOutputPort() {
		return nextOutputPort;
	}

	public void setNextOutputPort(int nextOutputPort) {
		this.nextOutputPort = nextOutputPort;
	}
	
	public SensorTypeEnum getPort1Device() {
		return Port1Device;
	}

	public void setPort1Device(SensorTypeEnum port1Device) {
		Port1Device = port1Device;
	}

	public SensorTypeEnum getPort2Device() {
		return Port2Device;
	}

	public void setPort2Device(SensorTypeEnum port2Device) {
		Port2Device = port2Device;
	}

	public SensorTypeEnum getPort3Device() {
		return Port3Device;
	}

	public void setPort3Device(SensorTypeEnum port3Device) {
		Port3Device = port3Device;
	}

	public SensorTypeEnum getPort4Device() {
		return Port4Device;
	}

	public void setPort4Device(SensorTypeEnum port4Device) {
		Port4Device = port4Device;
	}

	public boolean isPortAMotor() {
		return PortAMotor;
	}

	public void setPortAMotor(boolean portAMotor) {
		PortAMotor = portAMotor;
	}

	public boolean isPortBMotor() {
		return PortBMotor;
	}

	public void setPortBMotor(boolean portBMotor) {
		PortBMotor = portBMotor;
	}

	public boolean isPortCMotor() {
		return PortCMotor;
	}

	public void setPortCMotor(boolean portCMotor) {
		PortCMotor = portCMotor;
	}

	public boolean isPortDMotor() {
		return PortDMotor;
	}

	public void setPortDMotor(boolean portDMotor) {
		PortDMotor = portDMotor;
	}
	

	/** For detailed information about shouldEnable methods, see interface Parameterizable java doc 
	 *  @see Parameterizable 
	 */

	public boolean shouldEnableStreamPortA() {
		return this.isPortAMotor();
	}

	public boolean shouldEnableStreamPortB() {
		return this.isPortBMotor();
	}

	public boolean shouldEnableStreamPortC() {
		return this.isPortCMotor();
	}

	public boolean shouldEnableStreamPortD() {
		return this.isPortDMotor();
	}
	
	public boolean shouldEnableStreamPort1() {
		return this.getPort1Device() !=SensorTypeEnum.NONE;
	}

	public boolean shouldEnableStreamPort2() {
		return this.getPort2Device() !=SensorTypeEnum.NONE;
	}

	public boolean shouldEnableStreamPort3() {
		return this.getPort3Device() !=SensorTypeEnum.NONE;
	}

	public boolean shouldEnableStreamPort4() {
		return this.getPort4Device() !=SensorTypeEnum.NONE;
	}

	@Override
	public String getConnectionManagerName() {
		return ConnectionManagerName;
	}
	public void setConnectionManagerName(String s) {
		ConnectionManagerName = s;
	}

}
