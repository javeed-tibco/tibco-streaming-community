package com.example.ev3;

import com.streambase.sb.*;
import com.streambase.sb.operator.*;
import com.streambase.sb.util.Util;

/**
 * Generated by JDT StreamBase Client Templates (Version: 10.6.1.2008190131).
 *
 * This class is used as a Java Operator in a StreamBase application.
 * One instance will be created for each Java Operator in a StreamBase 
 * application. 
 * <p>
 * Enqueue methods should only be called from processTuple.
 * @see Parameterizable
 * @see Operator
 * For in-depth information on implementing a custom Java Operator, please see
 * "Developing StreamBase Java Operators" in the StreamBase documentation.
 */
public class EV3StatusAdapter extends Operator implements Parameterizable {

	public static final long serialVersionUID = 1623698966801L;
	// Properties
	private OutputTypeEnum OutputType;

	// Enum definition for property OutputType
	public static enum OutputTypeEnum {
		RAW("Raw"), SI("SI"), PERCENT("Percent");

		private final String rep;

		private OutputTypeEnum(String s) {
			rep = s;
		}

		public String toString() {
			return rep;
		}
	}
	
	private boolean StreamPortA;
	private boolean StreamPortB;
	private boolean StreamPortC;
	private boolean StreamPortD;
	private boolean StreamPort1;
	private boolean StreamPort2;
	private boolean StreamPort3;
	private boolean StreamPort4;
	
	private EV3SharedObject connectTo;
	
	
	private String displayName = "MINDSTORMS EV3 Input Adapter";
	// Local variables
	private int inputPorts = 1;
	private int outputPorts = 8;
	private int nextOutputPort = 0;
	private Schema[] outputSchemas; // caches the Schemas given during init() for use at processTuple()
	
	//Input schema definition
	private static Schema.Field FIELD_TARGET_PORT = Schema.createField(DataType.STRING, "TargetPort");
	private static Schema.Field FIELD_STREAM = Schema.createField(DataType.BOOL, "Stream");
	private static Schema.Field FIELD_SENSOR_MODE  = Schema.createField(DataType.INT, "SensorMode");
	
	//Output schema fieldnames
	private static String FIELD_DEGREES = "Degrees";
	private static String FIELD_ROTATION = "Rotation";
	private static String FIELD_SPEED = "Speed";

	private static String FIELD_LEFT = "LeftButton";
	private static String FIELD_CENTER = "CenterButton";
	private static String FIELD_RIGHT = "RightButton";
	private static String FIELD_UP = "UpButton";
	private static String FIELD_DOWN = "DownButton";
	
	private static String FIELD_LISTEN = "Listen";
	private static String FIELD_TOUCH = "Touch";
	private static String FIELD_BUMPED = "Bumped";
	private static String FIELD_COLOR = "Color";
	private static String FIELD_REFLECT = "LightReflected";
	private static String FIELD_AMBIENT = "LightAmbient";
	private static String FIELD_DIST_CM = "Distance(cm)";
	private static String FIELD_DIST_IN = "Distance(in)";
	private static String FIELD_ANGLE = "Angle";
	private static String FIELD_RATE = "Rate";
	private static String FIELD_DISTANCE = "Distance";

	/**
	* The constructor is called when the Operator instance is created, but before the Operator 
	* is connected to the StreamBase application. We recommended that you set the initial input
	* port and output port count in the constructor by calling setPortHints(inPortCount, outPortCount).
	* The default is 1 input port, 1 output port. The constructor may also set default values for 
	* operator parameters. These values will be displayed in StreamBase Studio when a new instance
	* of this operator is  dragged to the canvas, and serve as the default values for omitted
	* optional parameters.
	 */
	public EV3StatusAdapter() {
		super();
		setPortHints(inputPorts, outputPorts);
		setDisplayName(displayName);
		setShortDisplayName(this.getClass().getSimpleName());
		setStreamPortA(false);
		setStreamPortB(false);
		setStreamPortC(false);
		setStreamPortD(false);
		setStreamPort1(false);
		setStreamPort2(false);
		setStreamPort3(false);
		setStreamPort4(false);
	}

	/**
	* The typecheck method is called after the Operator instance is connected in the StreamBase
	* application, allowing the Operator to validate its properties. The Operator class may 
	* change the number of input or output ports by calling the requireInputPortCount(portCount)
	* method or the setOutputSchema(schema, portNum) method. If the verifyInputPortCount method 
	* is passed a different number of ports than the Operator currently has, a PortMismatchException
	* (subtype of TypecheckException) is thrown.
	*/
	public void typecheck() throws TypecheckException {
		// typecheck: require a specific number of input ports
		requireInputPortCount(inputPorts);

		// TODO Ensure that all properties have valid values, and typecheck the input schemas here
		
		if (getInputSchema(0) == null || !getInputSchema(0).hasField(FIELD_TARGET_PORT.getName())) {
            throw new TypecheckException(String.format("The control port schema must at least have a field named %s of type String", FIELD_TARGET_PORT.getName()));
        }
		
		connectTo = EV3SharedObject.getEV3SharedObject();
		
		if (connectTo.manager == null) {
            throw new TypecheckException(String.format("The EV3 Status Adapter requires a EV3 Connection Manager to operate."));
        }else {
    		//Check that the connection has already been configured
    		if(!connectTo.operators.contains(this)) {
    			connectTo.operators.add(this);
    		}
        }

		// you must specify a setOutputSchema for each port, so that StreamBase Studio
		// knows how many output ports to draw for the output ports. If you do not
		// use setOutputSchema for each port, the Java Operator on the StreamBase Studio
		// canvas will not display the correct number of output ports.
		
		
		int portNumber = 0;
		
		//button port
		setOutputSchema(portNumber, createButtonOutputSchema(""));
		
		//one for each motor connected
		if (connectTo.manager.isPortAMotor()) {
			portNumber++;
			setOutputSchema(portNumber, createMotorOutputSchema(""));
			//getLogger().debug("Port A: true");
		}
		if (connectTo.manager.isPortBMotor()) {
			portNumber++;
			setOutputSchema(portNumber, createMotorOutputSchema(""));
			//getLogger().debug("Port B: true");
		}
		if (connectTo.manager.isPortCMotor()) {
			portNumber++;
			setOutputSchema(portNumber, createMotorOutputSchema(""));
			//getLogger().debug("Port C: true");
		}
		if (connectTo.manager.isPortDMotor()) {
			portNumber++;
			setOutputSchema(portNumber, createMotorOutputSchema(""));
			//getLogger().debug("Port D: true");
		}
		
		
		//one for each applicable sensor
		if (connectTo.manager.getPort1Device() != SensorTypeEnum.NONE) {
			portNumber++;
			setOutputSchema(portNumber, getSchemaForSensorType(connectTo.manager.getPort1Device()));
			//getLogger().debug("Port 1: " + connectTo.manager.getPort1Device());
		}
		if (connectTo.manager.getPort2Device() != SensorTypeEnum.NONE) {
			portNumber++;
			setOutputSchema(portNumber, getSchemaForSensorType(connectTo.manager.getPort2Device()));
			//getLogger().debug("Port 2: " + connectTo.manager.getPort2Device());
		}
		if (connectTo.manager.getPort3Device() != SensorTypeEnum.NONE) {
			portNumber++;
			setOutputSchema(portNumber, getSchemaForSensorType(connectTo.manager.getPort3Device()));
			//getLogger().debug("Port 3: " + connectTo.manager.getPort3Device());
		}
		if (connectTo.manager.getPort4Device() != SensorTypeEnum.NONE) {
			portNumber++;
			setOutputSchema(portNumber, getSchemaForSensorType(connectTo.manager.getPort4Device()));
			//getLogger().debug("Port 4: " + connectTo.manager.getPort4Device());
		}
		
		//getLogger().debug("Port number recalculated to "+ portNumber);
		//getLogger().debug("Is Port A a motor (according to status adapter's paired manager)?" + connectTo.manager.isPortAMotor());

	}

	/**
	* This method will be called by the StreamBase server for each Tuple given
	* to the Operator to process. This is the only time an operator should 
	* enqueue output Tuples.
	* @param inputPort the input port that the tuple is from (ports are zero based)
	* @param tuple the tuple from the given input port
	* @throws StreamBaseException Terminates the application.
	*/
	public void processTuple(int inputPort, Tuple tuple) throws StreamBaseException {
		if (getLogger().isInfoEnabled()) {
			getLogger().info("operator processing a tuple at input port" + inputPort);
		}
		// TODO only the first input port is processed; see the template code for typecheck()
		if (inputPort > 0) {
			getLogger().info("operator skipping tuple at input port" + inputPort);
			return;
		}

		// create a new output tuple from the Schema at the port we are about to send to
		Tuple out = outputSchemas[inputPort].createTuple();

		// TODO this template just copies each field value from input port 0 (the first input port)
		for (int i = 0; i < out.getSchema().getFieldCount(); ++i) {
			// note: best performance is achieved retrieving values through Tuple#getField(Schema.Field)
			out.setField(i, tuple.getField(i));
		}

		// nextOutputPort is used to send tuples by round-robin on every output port by this template.
		sendOutput(nextOutputPort, out);
		nextOutputPort = (nextOutputPort + 1) % outputPorts;
	}

	/**
	 * If typecheck succeeds, the init method is called before the StreamBase application
	 * is started. Note that your Operator class is not required to define the init method,
	 * unless (for example) you need to perform initialization of a resource such as a JDBC
	 * pool, if your operator is making JDBC calls. StreamBase Studio does not call this
	 * during authoring.
	 */
	public void init() throws StreamBaseException {
		super.init();
		// for best performance, consider caching input or output Schema.Field objects for
		// use later in processTuple()
		outputSchemas = new Schema[outputPorts];

		for (int i = 0; i < outputPorts; ++i) {
			outputSchemas[i] = getRuntimeOutputSchema(i);
		}
	}

	/**
	*  The shutdown method is called when the StreamBase server is in the process of shutting down.
	*/
	public void shutdown() {

	}
	
	/*
	 * Define types of schema:
	 * 
	 * Input:
	 * Control
	 * 
	 * Output:
	 * -ButtonOutput
	 * -MotorOutput
	 * -TouchOutput
	 * -ColorOutput
	 * -UltraOutput
	 * -GyroOutput
	 * -IROutput
	 */
	
	public Schema createButtonOutputSchema(String mainName) {
		Schema buttonSchema = new Schema(mainName + (Util.isEmpty(mainName) ? "" : "buttonSchema"),
				new Schema.Field(FIELD_LEFT,CompleteDataType.forString()),
				new Schema.Field(FIELD_CENTER,CompleteDataType.forString()),
				new Schema.Field(FIELD_RIGHT,CompleteDataType.forString()),
				new Schema.Field(FIELD_UP,CompleteDataType.forString()),
				new Schema.Field(FIELD_DOWN,CompleteDataType.forString())
				);
		return buttonSchema;
	}
	
	 public Schema createMotorOutputSchema(String mainName) {
		 CompleteDataType returnType = OutputType == OutputTypeEnum.PERCENT? CompleteDataType.forInt() : CompleteDataType.forDouble();
		 //if a percentage is requested, it will be an integer; otherwise a double
	        Schema motorSchema = new Schema(mainName + (Util.isEmpty(mainName) ? "" : "motorSchema"),
	                    new Schema.Field(FIELD_DEGREES,returnType),
	                    new Schema.Field(FIELD_ROTATION,returnType),
	                    new Schema.Field(FIELD_SPEED,returnType)
	                    );
	        return motorSchema;
	 }
	 
	 public Schema getSchemaForSensorType (SensorTypeEnum type) {
		 switch(type) {
		 case TOUCH:
			 return createTouchOutputSchema("");
		 case COLOR:
			 return createColorOutputSchema("");
		 case ULTRA:
			 return createUltraOutputSchema("");
		 case GYRO:
			 return createGyroOutputSchema("");
		 case IR:
			 return createIROutputSchema("");
			 default:
				 return createMotorOutputSchema("");
		 }
	 }
	 
	 public Schema createTouchOutputSchema(String mainName) {
		 CompleteDataType returnType = OutputType == OutputTypeEnum.PERCENT? CompleteDataType.forInt() : CompleteDataType.forDouble();
		 //if a percentage is requested, it will be an integer; otherwise a double
	        Schema touchSchema = new Schema(mainName + (Util.isEmpty(mainName) ? "" : "touchSchema"),
	                    new Schema.Field(FIELD_TOUCH,returnType),
	                    new Schema.Field(FIELD_BUMPED,CompleteDataType.forBoolean())
	                    );
	        return touchSchema;
	 }
	 
	 public Schema createColorOutputSchema(String mainName) {
		 CompleteDataType returnType = OutputType == OutputTypeEnum.PERCENT? CompleteDataType.forInt() : CompleteDataType.forDouble();
		 //if a percentage is requested, it will be an integer; otherwise a double
	        Schema colorSchema = new Schema(mainName + (Util.isEmpty(mainName) ? "" : "colorSchema"),
	        		new Schema.Field(FIELD_COLOR,CompleteDataType.forString()),
	        		new Schema.Field(FIELD_REFLECT, returnType),
	        		new Schema.Field(FIELD_AMBIENT, returnType)
	                    );
	        return colorSchema;
	 }
	 
	 public static enum ColorEnum {
			NONE("None"), BLACK("Black"),BLUE("Blue"),GREEN("Green"),YELLOW("Yellow"),RED("Red"),WHITE("White"),BROWN("Brown");

			private final String rep;

			private ColorEnum(String s) {
				rep = s;
			}

			public String toString() {
				return rep;
			}
		}
	 
	 public Schema createUltraOutputSchema(String mainName) {
		 CompleteDataType returnType = OutputType == OutputTypeEnum.PERCENT? CompleteDataType.forInt() : CompleteDataType.forDouble();
		 //if a percentage is requested, it will be an integer; otherwise a double
	        Schema ultraSchema = new Schema(mainName + (Util.isEmpty(mainName) ? "" : "ultraSchema"),
	                    new Schema.Field(FIELD_DIST_CM,returnType),
	                    new Schema.Field(FIELD_DIST_IN,returnType),
	                    new Schema.Field(FIELD_LISTEN,CompleteDataType.forBoolean())
	                    );
	        return ultraSchema;
	 }
	 
	 public Schema createGyroOutputSchema(String mainName) {
		 CompleteDataType returnType = OutputType == OutputTypeEnum.PERCENT? CompleteDataType.forInt() : CompleteDataType.forDouble();
		 //if a percentage is requested, it will be an integer; otherwise a double
	        Schema gyroSchema = new Schema(mainName + (Util.isEmpty(mainName) ? "" : "gyroSchema"),
	                    new Schema.Field(FIELD_ANGLE,returnType),
	                    new Schema.Field(FIELD_RATE,returnType)
	                    );
	        return gyroSchema;
	 }
	 
	 public Schema createIROutputSchema(String mainName) {
		 CompleteDataType returnType = OutputType == OutputTypeEnum.PERCENT? CompleteDataType.forInt() : CompleteDataType.forDouble();
		 //if a percentage is requested, it will be an integer; otherwise a double
	        Schema IRSchema = new Schema(mainName + (Util.isEmpty(mainName) ? "" : "irSchema"),
	                    new Schema.Field(FIELD_DISTANCE,returnType)
	                    );
	        return IRSchema;
	 }

	/***************************************************************************************
	 * The getter and setter methods provided by the Parameterizable object.               *
	 * StreamBase Studio uses them to determine the name and type of each property         *
	 * and obviously, to set and get the property values.                                  *
	 ***************************************************************************************/

	public void setOutputType(OutputTypeEnum OutputType) {
		this.OutputType = OutputType;
	}

	public OutputTypeEnum getOutputType() {
		return this.OutputType;
	}

	public void setStreamPortA(boolean StreamPortA) {
		this.StreamPortA = StreamPortA;
	}

	public boolean getStreamPortA() {
		return this.StreamPortA;
	}

	public void setStreamPortB(boolean StreamPortB) {
		this.StreamPortB = StreamPortB;
	}

	public boolean getStreamPortB() {
		return this.StreamPortB;
	}

	public void setStreamPortC(boolean StreamPortC) {
		this.StreamPortC = StreamPortC;
	}

	public boolean getStreamPortC() {
		return this.StreamPortC;
	}

	public void setStreamPortD(boolean StreamPortD) {
		this.StreamPortD = StreamPortD;
	}

	public boolean getStreamPortD() {
		return this.StreamPortD;
	}

	public void setStreamPort1(boolean StreamPort1) {
		this.StreamPort1 = StreamPort1;
	}

	public boolean getStreamPort1() {
		return this.StreamPort1;
	}

	public void setStreamPort2(boolean StreamPort2) {
		this.StreamPort2 = StreamPort2;
	}

	public boolean getStreamPort2() {
		return this.StreamPort2;
	}

	public void setStreamPort3(boolean StreamPort3) {
		this.StreamPort3 = StreamPort3;
	}

	public boolean getStreamPort3() {
		return this.StreamPort3;
	}

	public void setStreamPort4(boolean StreamPort4) {
		this.StreamPort4 = StreamPort4;
	}

	public boolean getStreamPort4() {
		return this.StreamPort4;
	}

	public int getNextOutputPort() {
		return nextOutputPort;
	}

	public void setNextOutputPort(int nextOutputPort) {
		this.nextOutputPort = nextOutputPort;
	}

	/** For detailed information about shouldEnable methods, see interface Parameterizable java doc 
	 *  @see Parameterizable 
	 */

	public boolean shouldEnableStreamPortA() {
		return connectTo.manager == null? false : connectTo.manager.isPortAMotor();
	}

	public boolean shouldEnableStreamPortB() {
		return connectTo.manager == null? false : connectTo.manager.isPortBMotor();
	}

	public boolean shouldEnableStreamPortC() {
		return connectTo.manager == null? false : connectTo.manager.isPortCMotor();
	}

	public boolean shouldEnableStreamPortD() {
		return connectTo.manager == null? false : connectTo.manager.isPortDMotor();
	}


}
