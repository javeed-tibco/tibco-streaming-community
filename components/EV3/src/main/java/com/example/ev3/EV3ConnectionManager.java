package com.example.ev3;

import com.j4ev3.core.Sensor;
import com.streambase.sb.*;
import com.streambase.sb.operator.*;

/**
 * Generated by JDT StreamBase Client Templates (Version: 10.6.1.2008190131).
 *
 * This class is used as a Java Operator in a StreamBase application.
 * One instance will be created for each Java Operator in a StreamBase 
 * application. 
 * <p>
 * Enqueue methods should only be called from processTuple.
 * @see Parameterizable
 * @see Operator
 * For in-depth information on implementing a custom Java Operator, please see
 * "Developing StreamBase Java Operators" in the StreamBase documentation.
 */
public class EV3ConnectionManager extends Operator implements Parameterizable {

	public static final long serialVersionUID = 1623849395795L;
	private String displayName = "EV3 Connection Manager";
	
	//Properties
	private String MACaddress;
	
	private SensorTypeEnum Port1Device;
	private SensorTypeEnum Port2Device;
	private SensorTypeEnum Port3Device;
	private SensorTypeEnum Port4Device;
	
	private boolean PortAMotor;
	private boolean PortBMotor;
	private boolean PortCMotor;
	private boolean PortDMotor;
	
	//shared object
	private EV3SharedObject connectTo;
	
	
	// Local variables
	private int inputPorts = 0;
	private int outputPorts = 0;
	private Schema[] outputSchemas; // caches the Schemas given during init() for use at processTuple()
	

	/**
	* The constructor is called when the Operator instance is created, but before the Operator 
	* is connected to the StreamBase application. We recommended that you set the initial input
	* port and output port count in the constructor by calling setPortHints(inPortCount, outPortCount).
	* The default is 1 input port, 1 output port. The constructor may also set default values for 
	* operator parameters. These values will be displayed in StreamBase Studio when a new instance
	* of this operator is  dragged to the canvas, and serve as the default values for omitted
	* optional parameters.
	 */
	public EV3ConnectionManager() {
		super();
		setPortHints(inputPorts, outputPorts);
		setDisplayName(displayName);
		setShortDisplayName(this.getClass().getSimpleName());
		
		connectTo = EV3SharedObject.getEV3SharedObject();
		
		setMACaddress("");
		
		setPort1Device(SensorTypeEnum.NONE);
		setPort2Device(SensorTypeEnum.NONE);
		setPort3Device(SensorTypeEnum.NONE);
		setPort4Device(SensorTypeEnum.NONE);
		
		setPortAMotor(false);
		setPortBMotor(false);
		setPortCMotor(false);
		setPortDMotor(false);
	}

	/**
	* The typecheck method is called after the Operator instance is connected in the StreamBase
	* application, allowing the Operator to validate its properties. The Operator class may 
	* change the number of input or output ports by calling the requireInputPortCount(portCount)
	* method or the setOutputSchema(schema, portNum) method. If the verifyInputPortCount method 
	* is passed a different number of ports than the Operator currently has, a PortMismatchException
	* (subtype of TypecheckException) is thrown.
	*/
	public void typecheck() throws TypecheckException {
		// typecheck: require a specific number of input ports
		requireInputPortCount(inputPorts);
		
		//check that shared object is properly paired
		if (connectTo.manager == null || !connectTo.manager.equals(this)) {
			connectTo.manager = this;
		}
		
		if(MACaddress.length() != 12) {//TODO:check that it's a hex number
			throw new TypecheckException(String.format("The adapter requires a 12-character Bluetooth MAC address."));
		}

	}

	/**
	* This method will be called by the StreamBase server for each Tuple given
	* to the Operator to process. This is the only time an operator should 
	* enqueue output Tuples.
	* @param inputPort the input port that the tuple is from (ports are zero based)
	* @param tuple the tuple from the given input port
	* @throws StreamBaseException Terminates the application.
	*/
	public void processTuple(int inputPort, Tuple tuple) throws StreamBaseException {
		if (getLogger().isInfoEnabled()) {
			getLogger().info("operator processing a tuple at input port" + inputPort);
		}
		//This operator does not have an input port and does not process tuples.
	}

	/**
	 * If typecheck succeeds, the init method is called before the StreamBase application
	 * is started. Note that your Operator class is not required to define the init method,
	 * unless (for example) you need to perform initialization of a resource such as a JDBC
	 * pool, if your operator is making JDBC calls. StreamBase Studio does not call this
	 * during authoring.
	 */
	public void init() throws StreamBaseException {
		super.init();
		// for best performance, consider caching input or output Schema.Field objects for
		// use later in processTuple()
		outputSchemas = new Schema[outputPorts];

		for (int i = 0; i < outputPorts; ++i) {
			outputSchemas[i] = getRuntimeOutputSchema(i);
		}
		
		//TODO: connect to robot; store it in shared object
		connectTo.run(MACaddress);
		getLogger().debug("HELLO HI DON'T MISS ME HELLO HI DON'T MISS MEHELLO HI DON'T MISS ME HELLO HI DON'T MISS ME HELLO HI DON'T MISS ME HELLO HI DON'T MISS ME HELLO HI DON'T MISS ME");
		getLogger().debug(connectTo.robot.getSensor().getDeviceModeName(Sensor.PORT_1, 0, 10));
	}

	/**
	*  The shutdown method is called when the StreamBase server is in the process of shutting down.
	*/
	public void shutdown() {
		connectTo.manager = null;

	}
	
	//Visibility rules
	public boolean shouldEnableStreamPort1() {
		return Port1Device!=SensorTypeEnum.NONE;
	}

	public boolean shouldEnableStreamPort2() {
		return Port2Device!=SensorTypeEnum.NONE;
	}

	public boolean shouldEnableStreamPort3() {
		return Port3Device!=SensorTypeEnum.NONE;
	}

	public boolean shouldEnableStreamPort4() {
		return Port4Device!=SensorTypeEnum.NONE;
	}

	//Getters & setters
	public String getMACaddress() {
		return MACaddress;
	}

	public void setMACaddress(String settingForSharedObject) {
		this.MACaddress = settingForSharedObject;
	}

	public SensorTypeEnum getPort1Device() {
		return Port1Device;
	}

	public void setPort1Device(SensorTypeEnum port1Device) {
		Port1Device = port1Device;
	}

	public SensorTypeEnum getPort2Device() {
		return Port2Device;
	}

	public void setPort2Device(SensorTypeEnum port2Device) {
		Port2Device = port2Device;
	}

	public SensorTypeEnum getPort3Device() {
		return Port3Device;
	}

	public void setPort3Device(SensorTypeEnum port3Device) {
		Port3Device = port3Device;
	}

	public SensorTypeEnum getPort4Device() {
		return Port4Device;
	}

	public void setPort4Device(SensorTypeEnum port4Device) {
		Port4Device = port4Device;
	}

	public boolean isPortAMotor() {
		return PortAMotor;
	}

	public void setPortAMotor(boolean portAMotor) {
		PortAMotor = portAMotor;
	}

	public boolean isPortBMotor() {
		return PortBMotor;
	}

	public void setPortBMotor(boolean portBMotor) {
		PortBMotor = portBMotor;
	}

	public boolean isPortCMotor() {
		return PortCMotor;
	}

	public void setPortCMotor(boolean portCMotor) {
		PortCMotor = portCMotor;
	}

	public boolean isPortDMotor() {
		return PortDMotor;
	}

	public void setPortDMotor(boolean portDMotor) {
		PortDMotor = portDMotor;
	}
	
	

}
